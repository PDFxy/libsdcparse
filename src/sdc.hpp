#ifndef SDC_H
#define SDC_H
/*
 * libsdcparse - Kevin E. Murray 2014
 *
 * Released under MIT License see LICENSE.txt for details.
 *
 * OVERVIEW
 * --------------------------
 * This library provides basic parsing capabilities for a subset of commands in
 * Synopsys Design Constraint (SDC) files.  SDC files are typically used to 
 * set timing constraints on digital circuits.
 *
 * USING THIS LIBRARY
 * --------------------------
 * Since this is NOT a full TCL interpreter, 'function calls' to get_ports or
 * get_clocks, are converted to string_group, with the group_type field set
 * to either SDC_CLOCK or SDC_PORT respectively. That is, they are represented as 
 * the sets of the strings passed to those functions.  It is left up to the 
 * application to interpret them.
 *
 * After parsing, each SDC command is represented as a C struct.  Typically each
 * command is parsed into a unique type of struct, however some closely related commands
 * (such as set_input_delay and set_output_delay) may share a struct and be identified
 * by a 'type' field in the struct.
 *
 * All supported SDC commands are collected into a commands struct which
 * represents the entire SDC file.
 *
 * See the associated main.c for example usage.
 *
 * EXTENDING THE LIBRARY
 * --------------------------
 * The parser uses a lexer generated by 'flex' (see sdc_parse.l), and a parser
 * generated by 'bison' (see sdc_parse.y).
 *
 * While the parser currently supports only a subset of the full SDC specification,
 * it should be relatively straightforward to extend it as follows:
 *
 *      1) To add a new option to an existing command
 *          a) Add the new token definition to sdc_parse.y (e.g. ARG_HOLD)
 *          b) Add a pattern to sdc_parse.l which returns the token (e.g. '-hold')
 *          c) Add a new (optional) rule to the appropriate command in sdc_parse.y
 *          d) Add an action for the added rule which makes the appropriate
 *             modifications to the command's struct.  It likely that you will
 *             want to do this as a function call and put the function definition
 *             in sdc_common.c. If the option may conflict with others it is
 *             typically checked at this point, with errors reported using sdc_error().
 *          e) Command is automatically added using the appropriate add_sdc*()
 *             function, which also verifies the options.  Command level consistency
 *             checks (e.g. option required) typically go here.
 *
 *      2) To add a new command
 *          a) Add the new token definition to sdc_parse.y (e.g. CMD_SET_TIME_FORMAT)
 *          b) Add a pattern to sdc_parse.l which returns the token (e.g. 'set_time_format')
 *          c) Add a new rule for the command to sdc_parse.y e.g.:
 *                cmd_set_time_format: CMD_SET_TIME_FORMAT
 *          d) Create a new C struct to represent the command, and write an alloc function
 *             (in sdc_common.c) that is called by the first rule e.g.:
 *                cmd_set_time_format: CMD_SET_TIME_FORMAT {$$ = alloc_sdc_set_time_units();}
 *          c) Add options to the command as outlined in (1)
 *          d) Create an add_sdc*() command and extend the s_sdc_commands struct to include 
 *             the new command.  Call it in the top level sdc_commands rule e.g.:
 *
 *                sdc_commands: ...
 *                   | ... //Other commands
 *                   | sdc_commands cmd_set_time_format EOL {$$ = add_sdc_set_time_format($1, $2); }
 *
 */
#include <vector>
#include <string>
#include <memory>
#include <limits>
#include <functional>

namespace sdcparse {

//Sentinal values
constexpr double UNINITIALIZED_FLOAT = std::numeric_limits<double>::quiet_NaN();
constexpr int UNINITIALIZED_INT = -1;

/* 
 * The default sdc_error() implementation.
 * By default it prints the error mesage to stderr and exits the program.
 */
void default_sdc_error(const int line_number, const std::string& near_text, const std::string& msg);

/*
 * libsdc calls sdc_error() to report errors encountered while parsing an SDC file.  
 *
 * If you wish to define your own error reporting function (e.g. to throw exceptions instead
 * of exit) you can change the behaviour by providing another callable type which matches the signature.
 *
 * The return type is void, while the arguments are:
 *     1) const int line_no            - the file line number
 *     2) const std::string& near_text - the text the parser encountered 'near' the error
 *     3) const std::string& msg       - the error message
 */
void set_sdc_error_handler(std::function<void(const int, const std::string&, const std::string&)> new_sdc_error_handler);


/*
 * Forward declarations
 */
struct SdcCommands;

struct CreateClock;
struct SetIoDelay;
struct SetClockGroups;
struct SetFalsePath;
struct SetMaxDelay;
struct SetMulticyclePath;

struct StringGroup;

/*
 * Enumerations to describe specific SDC command types and attributes
 */
enum class IoDelayType {
    INPUT, 
    OUTPUT
};

enum class ClockGroupsType {
    NONE,
    EXCLUSIVE
};

enum class FromToType {
    FROM,
    TO
};

enum class McpType {
    NONE, 
    SETUP
};

enum class StringGroupType {
    STRING, 
    PORT, 
    CLOCK
};

/*
 * Collection of SDC commands
 */
struct SdcCommands {
    bool has_commands();

    std::vector<CreateClock> create_clock_cmds;
    std::vector<SetIoDelay> set_input_delay_cmds;
    std::vector<SetIoDelay> set_output_delay_cmds;
    std::vector<SetClockGroups> set_clock_groups_cmds;
    std::vector<SetFalsePath> set_false_path_cmds;
    std::vector<SetMaxDelay> set_max_delay_cmds;
    std::vector<SetMulticyclePath> set_multicycle_path_cmds;
};

/*
 * Common SDC data structures
 */

struct StringGroup {
    StringGroup() = default;
    StringGroup(StringGroupType type)
        : group_type(type) {}

    StringGroupType group_type = StringGroupType::STRING;   //The type of the string group, default is STRING. 
                                                            //Groups derived from 'calls' to [get_clocks {...}] 
                                                            //and [get_ports {...}] will have types SDC_CLOCK 
                                                            //and SDC_PORT respectively.
    std::vector<std::string> strings;                       //The strings in the group
};

/*
 * Structures defining different SDC commands
 */
struct CreateClock {
    std::string name = "";                      //Name of the clock
    double period = UNINITIALIZED_FLOAT;        //Clock period
    double rise_edge = UNINITIALIZED_FLOAT;     //Rise time from waveform definition
    double fall_edge = UNINITIALIZED_FLOAT;     //Fall time from waveform definition
    StringGroup targets;                        //The set of strings indicating clock sources.
                                                // May be explicit strings or regexs.
    bool is_virtual = false;                    //Identifies this as a virtual (non-netlist) clock

    int file_line_number = UNINITIALIZED_INT;   //Line number where this command is defined
};

struct SetIoDelay {
    SetIoDelay() = default;
    SetIoDelay(IoDelayType type)
        : io_type(type) {}

    IoDelayType io_type = IoDelayType::INPUT;       //Identifies whether this represents a
                                                    // set_input_delay or set_output delay
                                                    // command.
    std::string clock_name = "";                    //Name of the clock this constraint is associated with
    double max_delay = UNINITIALIZED_FLOAT;         //The maximum input delay allowed on the target ports
    StringGroup target_ports;                       //The target ports

    int file_line_number = UNINITIALIZED_INT;       //Line number where this command is defined
};

struct SetClockGroups {
    ClockGroupsType cg_type = ClockGroupsType::NONE;   //The type of clock group relation being specified
    std::vector<StringGroup> clock_groups;          //The groups of clocks

    int file_line_number = UNINITIALIZED_INT;       //Line number where this command is defined
};

struct SetFalsePath {
    StringGroup from;                           //The source list of startpoints or clocks
    StringGroup to;                             //The target list of endpoints or clocks
                                                
    int file_line_number = UNINITIALIZED_INT;   //Line number where this command is defined
};

struct SetMaxDelay {
    double max_delay = UNINITIALIZED_FLOAT;     //The maximum allowed delay between the from
                                                // and to clocks
    StringGroup from;                           //The source list of startpoints or clocks
    StringGroup to;                             //The target list of endpoints or clocks

    int file_line_number = UNINITIALIZED_INT;   //Line number where this command is defined
};

struct SetMulticyclePath {
    McpType mcp_type = McpType::NONE;               //The type of the mcp
    int mcp_value = UNINITIALIZED_INT;          //The number of cycles specifed
    StringGroup from;                           //The source list of startpoints or clocks
    StringGroup to;                             //The target list of endpoints or clocks

    int file_line_number = UNINITIALIZED_INT;   //Line number where this command is defined
};

/*
 *  Externally useful functions
 */
std::shared_ptr<SdcCommands> sdc_parse_filename(std::string filename);
std::shared_ptr<SdcCommands> sdc_parse_filename(const char* filename);
std::shared_ptr<SdcCommands> sdc_parse_file(FILE* sdc);

} //namespace

#endif
